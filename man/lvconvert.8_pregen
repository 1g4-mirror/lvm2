.TH LVCONVERT 8 "LVM TOOLS #VERSION#" "Red Hat, Inc."
.
.SH NAME
.
lvconvert \(em Change logical volume layout
.
.SH SYNOPSIS
.
.nh
.TP
\fBlvconvert\fP \fIoption_args\fP \fIposition_args\fP
[ \fIoption_args\fP ]
.br
[ \fIposition_args\fP ]
.P
.na
.RS
\0\0\0\fB--alloc\fP \%\fBcontiguous\fP|\:\c
\fBcling\fP|\:\c
\fBcling_by_tags\fP|\:\c
\fBnormal\fP|\:\c
\fBanywhere\fP|\:\c
\fBinherit\fP
.br
\fB-b\fP|\fB--background\fP
.br
\fB-H\fP|\fB--cache\fP
.br
\0\0\0\fB--cachedevice\fP \fIPV\fP
.br
\0\0\0\fB--cachemetadataformat\fP \fBauto\fP|\fB1\fP|\fB2\fP
.br
\0\0\0\fB--cachemode\fP \%\fBwritethrough\fP|\:\c
\fBwriteback\fP|\:\c
\fBpassthrough\fP
.br
\0\0\0\fB--cachepolicy\fP \fIString\fP
.br
\0\0\0\fB--cachepool\fP \fILV\fP
.br
\0\0\0\fB--cachesettings\fP \fIString\fP
.br
\0\0\0\fB--cachesize\fP \fISize\fP[m|\:UNIT]
.br
\0\0\0\fB--cachevol\fP \fILV\fP
.br
\fB-c\fP|\fB--chunksize\fP \fISize\fP[k|\:UNIT]
.br
\0\0\0\fB--commandprofile\fP \fIString\fP
.br
\0\0\0\fB--compression\fP \fBy\fP|\fBn\fP
.br
\0\0\0\fB--config\fP \fIString\fP
.br
\fB-d\fP|\fB--debug\fP
.br
\0\0\0\fB--deduplication\fP \fBy\fP|\fBn\fP
.br
\0\0\0\fB--devices\fP \fIPV\fP
.br
\0\0\0\fB--devicesfile\fP \fIString\fP
.br
\0\0\0\fB--discards\fP \%\fBpassdown\fP|\:\c
\fBnopassdown\fP|\:\c
\fBignore\fP
.br
\0\0\0\fB--driverloaded\fP \fBy\fP|\fBn\fP
.br
\0\0\0\fB--errorwhenfull\fP \fBy\fP|\fBn\fP
.br
\fB-f\fP|\fB--force\fP
.br
\fB-h\fP|\fB--help\fP
.br
\0\0\0\fB--integritysettings\fP \fIString\fP
.br
\fB-i\fP|\fB--interval\fP \fINumber\fP
.br
\0\0\0\fB--journal\fP \fIString\fP
.br
\0\0\0\fB--lockopt\fP \fIString\fP
.br
\0\0\0\fB--longhelp\fP
.br
\0\0\0\fB--merge\fP
.br
\0\0\0\fB--mergemirrors\fP
.br
\0\0\0\fB--mergesnapshot\fP
.br
\0\0\0\fB--mergethin\fP
.br
\0\0\0\fB--metadataprofile\fP \fIString\fP
.br
\0\0\0\fB--mirrorlog\fP \fBcore\fP|\fBdisk\fP
.br
\fB-m\fP|\fB--mirrors\fP [\fB+\fP|\fB-\fP]\fINumber\fP
.br
\fB-n\fP|\fB--name\fP \fIString\fP
.br
\0\0\0\fB--nohints\fP
.br
\0\0\0\fB--nolocking\fP
.br
\0\0\0\fB--noudevsync\fP
.br
\0\0\0\fB--originname\fP \fILV\fP
.br
\0\0\0\fB--pooldatavdo\fP \fBy\fP|\fBn\fP
.br
\0\0\0\fB--poolmetadata\fP \fILV\fP
.br
\0\0\0\fB--poolmetadatasize\fP \fISize\fP[m|\:UNIT]
.br
\0\0\0\fB--poolmetadataspare\fP \fBy\fP|\fBn\fP
.br
\0\0\0\fB--profile\fP \fIString\fP
.br
\fB-q\fP|\fB--quiet\fP
.br
\0\0\0\fB--raidintegrity\fP \fBy\fP|\fBn\fP
.br
\0\0\0\fB--raidintegrityblocksize\fP \fINumber\fP
.br
\0\0\0\fB--raidintegritymode\fP \fIString\fP
.br
\fB-r\fP|\fB--readahead\fP \%\fBauto\fP|\:\c
\fBnone\fP|\:\c
\fINumber\fP
.br
\fB-R\fP|\fB--regionsize\fP \fISize\fP[m|\:UNIT]
.br
\0\0\0\fB--repair\fP
.br
\0\0\0\fB--replace\fP \fIPV\fP
.br
\fB-k\fP|\fB--setactivationskip\fP \fBy\fP|\fBn\fP
.br
\fB-s\fP|\fB--snapshot\fP
.br
\0\0\0\fB--splitcache\fP
.br
\0\0\0\fB--splitmirrors\fP \fINumber\fP
.br
\0\0\0\fB--splitsnapshot\fP
.br
\0\0\0\fB--startpoll\fP
.br
\0\0\0\fB--stripes\fP \fINumber\fP
.br
\fB-I\fP|\fB--stripesize\fP \fISize\fP[k|\:UNIT]
.br
\0\0\0\fB--swapmetadata\fP
.br
\fB-t\fP|\fB--test\fP
.br
\fB-T\fP|\fB--thin\fP
.br
\0\0\0\fB--thinpool\fP \fILV\fP
.br
\0\0\0\fB--trackchanges\fP
.br
\0\0\0\fB--type\fP \%\fBlinear\fP|\:\c
\fBstriped\fP|\:\c
\fBsnapshot\fP|\:\c
\fBraid\fP|\:\c
\fBmirror\fP|\:\c
\fBthin\fP|\:\c
\fBthin-pool\fP|\:\c
\fBvdo\fP|\:\c
\fBvdo-pool\fP|\:\c
\fBcache\fP|\:\c
\fBcache-pool\fP|\:\c
\fBwritecache\fP
.br
\0\0\0\fB--uncache\fP
.br
\0\0\0\fB--usepolicies\fP
.br
\0\0\0\fB--vdopool\fP \fILV\fP
.br
\0\0\0\fB--vdosettings\fP \fIString\fP
.br
\fB-v\fP|\fB--verbose\fP
.br
\0\0\0\fB--version\fP
.br
\fB-V\fP|\fB--virtualsize\fP \fISize\fP[m|\:UNIT]
.br
\fB-W\fP|\fB--wipesignatures\fP \fBy\fP|\fBn\fP
.br
\fB-y\fP|\fB--yes\fP
.br
\fB-Z\fP|\fB--zero\fP \fBy\fP|\fBn\fP
.br
.RE
.ad
.hy
.
.SH DESCRIPTION
.
lvconvert changes the LV type and includes utilities for LV data
maintenance. The LV type controls data layout and redundancy.
The LV type is also called the segment type or segtype.
.P
To display the current LV type, run the command:
.P
.B lvs -o name,segtype
.I LV
.P
In some cases, an LV is a single device mapper (dm) layer above physical
devices.  In other cases, hidden LVs (dm devices) are layered between the
visible LV and physical devices.  LVs in the middle layers are called sub LVs.
A command run on a visible LV sometimes operates on a sub LV rather than
the specified LV.  In other cases, a sub LV must be specified directly on
the command line.
.P
Sub LVs can be displayed with the command:
.P
.B lvs -a
.P
The
.B linear
type is equivalent to the
.B striped
type when one stripe exists.
In that case, the types can sometimes be used interchangeably.
.P
In most cases, the
.B mirror
type is deprecated and the
.B raid1
type should be used.  They are both implementations of mirroring.
.P
Striped raid types are
\fBraid0/raid0_meta\fP,
\fBraid5\fP (an alias for raid5_ls),
\fBraid6\fP (an alias for raid6_zr) and
\fBraid10\fP (an alias for raid10_near).
.P
As opposed to mirroring, raid5 and raid6 stripe data and calculate parity
blocks. The parity blocks can be used for data block recovery in case
devices fail. A maximum number of one device in a raid5 LV may fail, and
two in case of raid6. Striped raid types typically rotate the parity and
data blocks for performance reasons, thus avoiding contention on a single
device. Specific arrangements of parity and data blocks (layouts) can be
used to optimize I/O performance, or to convert between raid levels.  See
\fBlvmraid\fP(7) for more information.
.P
Layouts of raid5 rotating parity blocks can be: left-asymmetric
(raid5_la), left-symmetric (raid5_ls with alias raid5), right-asymmetric
(raid5_ra), right-symmetric (raid5_rs) and raid5_n, which doesn't rotate
parity blocks. Layouts of raid6 are: zero-restart (raid6_zr with alias
raid6), next-restart (raid6_nr), and next-continue (raid6_nc).
.P
Layouts including _n allow for conversion between raid levels (raid5_n to
raid6 or raid5_n to striped/raid0/raid0_meta). Additionally, special raid6
layouts for raid level conversions between raid5 and raid6 are:
raid6_ls_6, raid6_rs_6, raid6_la_6 and raid6_ra_6. Those correspond to
their raid5 counterparts (e.g. raid5_rs can be directly converted to
raid6_rs_6 and vice-versa).
.P
raid10 (an alias for raid10_near) is currently limited to one data copy
and even number of sub LVs. This is a mirror group layout, thus a single
sub LV may fail per mirror group without data loss.
.P
Striped raid types support converting the layout, their stripesize and
their number of stripes.
.P
The striped raid types combined with raid1 allow for conversion from
linear \[->] striped/raid0/raid0_meta and vice-versa by e.g. linear \[<>] raid1
\[<>] raid5_n (then adding stripes) \[<>] striped/raid0/raid0_meta.
.
.SH USAGE
.
.nh
.na
Convert LV to linear.
.P
.B lvconvert
\fB--type\fP \fBlinear\fP
\fILV\fP
.RS
[ COMMON_OPTIONS ]
.br
[ \fIPV\fP.\|.\|. ]
.RE
.
.P
\(em
.P
.
Convert LV to striped.
.P
.B lvconvert
\fB--type\fP \fBstriped\fP
\fILV\fP
.RS
[ \fB-I\fP|\fB--stripesize\fP \fISize\fP[k|\:UNIT] ]
.br
[ \fB-R\fP|\fB--regionsize\fP \fISize\fP[m|\:UNIT] ]
.br
[ \fB-i\fP|\fB--interval\fP \fINumber\fP ]
.br
[ \0\0\0\fB--stripes\fP \fINumber\fP ]
.br
[ COMMON_OPTIONS ]
.br
[ \fIPV\fP.\|.\|. ]
.RE
.
.P
\(em
.P
.
Convert LV to type mirror (also see type raid1),
.P
.B lvconvert
\fB--type\fP \fBmirror\fP
\fILV\fP
.RS
[ \fB-m\fP|\fB--mirrors\fP [\fB+\fP|\fB-\fP]\fINumber\fP ]
.br
[ \fB-I\fP|\fB--stripesize\fP \fISize\fP[k|\:UNIT] ]
.br
[ \fB-R\fP|\fB--regionsize\fP \fISize\fP[m|\:UNIT] ]
.br
[ \fB-i\fP|\fB--interval\fP \fINumber\fP ]
.br
[ \0\0\0\fB--stripes\fP \fINumber\fP ]
.br
[ \0\0\0\fB--mirrorlog\fP \fBcore\fP|\fBdisk\fP ]
.br
[ COMMON_OPTIONS ]
.br
[ \fIPV\fP.\|.\|. ]
.RE
.
.P
\(em
.P
.
Convert LV to raid or change raid layout
(a specific raid level must be used, e.g. raid1).
.P
.B lvconvert
\fB--type\fP \fBraid\fP
\fILV\fP
.RS
[ \fB-m\fP|\fB--mirrors\fP [\fB+\fP|\fB-\fP]\fINumber\fP ]
.br
[ \fB-I\fP|\fB--stripesize\fP \fISize\fP[k|\:UNIT] ]
.br
[ \fB-R\fP|\fB--regionsize\fP \fISize\fP[m|\:UNIT] ]
.br
[ \fB-i\fP|\fB--interval\fP \fINumber\fP ]
.br
[ \0\0\0\fB--stripes\fP \fINumber\fP ]
.br
[ COMMON_OPTIONS ]
.br
[ \fIPV\fP.\|.\|. ]
.RE
.
.P
\(em
.P
.
Convert LV to raid1 or mirror, or change number of mirror images.
.P
.B lvconvert
\fB-m\fP|\fB--mirrors\fP [\fB+\fP|\fB-\fP]\fINumber\fP
\fILV\fP
.RS
[ \fB-R\fP|\fB--regionsize\fP \fISize\fP[m|\:UNIT] ]
.br
[ \fB-i\fP|\fB--interval\fP \fINumber\fP ]
.br
[ \0\0\0\fB--mirrorlog\fP \fBcore\fP|\fBdisk\fP ]
.br
[ COMMON_OPTIONS ]
.br
[ \fIPV\fP.\|.\|. ]
.RE
.
.P
\(em
.P
.
Convert raid LV to change number of stripe images.
.P
.B lvconvert
\fB--stripes\fP \fINumber\fP
\fILV1\fP
.RS
[ \fB-i\fP|\fB--interval\fP \fINumber\fP ]
.br
[ \fB-R\fP|\fB--regionsize\fP \fISize\fP[m|\:UNIT] ]
.br
[ \fB-I\fP|\fB--stripesize\fP \fISize\fP[k|\:UNIT] ]
.br
[ COMMON_OPTIONS ]
.br
[ \fIPV\fP.\|.\|. ]
.sp
LV1 types: raid
.RE
.
.P
\(em
.P
.
Convert raid LV to change the stripe size.
.P
.B lvconvert
\fB-I\fP|\fB--stripesize\fP \fISize\fP[k|\:UNIT]
\fILV1\fP
.RS
[ \fB-i\fP|\fB--interval\fP \fINumber\fP ]
.br
[ \fB-R\fP|\fB--regionsize\fP \fISize\fP[m|\:UNIT] ]
.br
[ COMMON_OPTIONS ]
.sp
LV1 types: raid
.RE
.
.P
\(em
.P
.
Split images from a raid1 or mirror LV and use them to create a new LV.
.P
.B lvconvert
\fB--splitmirrors\fP \fINumber\fP
\fB-n\fP|\fB--name\fP \fILV\fP\fI_new\fP
\fILV1\fP
.RS
[ COMMON_OPTIONS ]
.br
[ \fIPV\fP.\|.\|. ]
.sp
LV1 types: cache mirror raid1
.RE
.
.P
\(em
.P
.
Split images from a raid1 LV and track changes to origin for later merge.
.P
.B lvconvert
\fB--splitmirrors\fP \fINumber\fP
\fB--trackchanges\fP
\fILV1\fP
.RS
[ COMMON_OPTIONS ]
.br
[ \fIPV\fP.\|.\|. ]
.sp
LV1 types: cache raid1
.RE
.
.P
\(em
.P
.
Merge LV images that were split from a raid1 LV.
.P
.B lvconvert
\fB--mergemirrors\fP
\fIVG\fP|\fILV1\fP|\fITag\fP.\|.\|.
.RS
[ COMMON_OPTIONS ]
.sp
LV1 types: linear raid
.RE
.
.P
\(em
.P
.
Convert LV to a thin LV, using the original LV as an external origin.
.P
.B lvconvert
\fB--type\fP \fBthin\fP
\fB--thinpool\fP \fILV\fP
\fILV1\fP
.RS
[ \fB-T\fP|\fB--thin\fP ]
.br
[ \fB-c\fP|\fB--chunksize\fP \fISize\fP[k|\:UNIT] ]
.br
[ \fB-r\fP|\fB--readahead\fP \%\fBauto\fP|\:\c
\fBnone\fP|\:\c
\fINumber\fP ]
.br
[ \fB-W\fP|\fB--wipesignatures\fP \fBy\fP|\fBn\fP ]
.br
[ \fB-Z\fP|\fB--zero\fP \fBy\fP|\fBn\fP ]
.br
[ \0\0\0\fB--originname\fP \fILV\fP\fI_new\fP ]
.br
[ \0\0\0\fB--poolmetadata\fP \fILV\fP ]
.br
[ \0\0\0\fB--poolmetadatasize\fP \fISize\fP[m|\:UNIT] ]
.br
[ \0\0\0\fB--poolmetadataspare\fP \fBy\fP|\fBn\fP ]
.br
[ \0\0\0\fB--metadataprofile\fP \fIString\fP ]
.br
[ COMMON_OPTIONS ]
.br
[ \fIPV\fP.\|.\|. ]
.sp
LV1 types: linear striped cache raid thin zero error
.RE
.
.P
\(em
.P
.
Convert LV to a thin LV, using LV as thin-pool data volume.
.P
.B lvconvert
\fB--type\fP \fBthin\fP
\fILV1\fP
.RS
[ \fB-T\fP|\fB--thin\fP ]
.br
[ \fB-c\fP|\fB--chunksize\fP \fISize\fP[k|\:UNIT] ]
.br
[ \fB-r\fP|\fB--readahead\fP \%\fBauto\fP|\:\c
\fBnone\fP|\:\c
\fINumber\fP ]
.br
[ \fB-W\fP|\fB--wipesignatures\fP \fBy\fP|\fBn\fP ]
.br
[ \fB-Z\fP|\fB--zero\fP \fBy\fP|\fBn\fP ]
.br
[ \0\0\0\fB--poolmetadata\fP \fILV\fP ]
.br
[ \0\0\0\fB--poolmetadatasize\fP \fISize\fP[m|\:UNIT] ]
.br
[ \0\0\0\fB--poolmetadataspare\fP \fBy\fP|\fBn\fP ]
.br
[ \0\0\0\fB--metadataprofile\fP \fIString\fP ]
.br
[ COMMON_OPTIONS ]
.br
[ \fIPV\fP.\|.\|. ]
.sp
LV1 types: linear striped cache raid vdo writecache zero error
.RE
.
.P
\(em
.P
.
Attach a cache pool to an LV, converts the LV to type cache.
.P
.B lvconvert
\fB--type\fP \fBcache\fP
\fB--cachepool\fP \fILV\fP
\fILV1\fP
.RS
[ \fB-H\fP|\fB--cache\fP ]
.br
[ \fB-Z\fP|\fB--zero\fP \fBy\fP|\fBn\fP ]
.br
[ \fB-c\fP|\fB--chunksize\fP \fISize\fP[k|\:UNIT] ]
.br
[ \fB-r\fP|\fB--readahead\fP \%\fBauto\fP|\:\c
\fBnone\fP|\:\c
\fINumber\fP ]
.br
[ \fB-W\fP|\fB--wipesignatures\fP \fBy\fP|\fBn\fP ]
.br
[ \0\0\0\fB--cachemetadataformat\fP \fBauto\fP|\fB1\fP|\fB2\fP ]
.br
[ \0\0\0\fB--cachemode\fP \%\fBwritethrough\fP|\:\c
\fBwriteback\fP|\:\c
\fBpassthrough\fP ]
.br
[ \0\0\0\fB--cachepolicy\fP \fIString\fP ]
.br
[ \0\0\0\fB--cachesettings\fP \fIString\fP ]
.br
[ \0\0\0\fB--poolmetadata\fP \fILV\fP ]
.br
[ \0\0\0\fB--poolmetadatasize\fP \fISize\fP[m|\:UNIT] ]
.br
[ \0\0\0\fB--poolmetadataspare\fP \fBy\fP|\fBn\fP ]
.br
[ \0\0\0\fB--metadataprofile\fP \fIString\fP ]
.br
[ COMMON_OPTIONS ]
.br
[ \fIPV\fP.\|.\|. ]
.sp
LV1 types: linear striped raid thin thinpool vdo vdopool vdopooldata zero error
.RE
.
.P
\(em
.P
.
Attach a writecache to an LV, converts the LV to type writecache.
.P
.B lvconvert
\fB--type\fP \fBwritecache\fP
\fB--cachevol\fP \fILV\fP
\fILV1\fP
.RS
[ \0\0\0\fB--cachesettings\fP \fIString\fP ]
.br
[ COMMON_OPTIONS ]
.sp
LV1 types: linear striped raid thinpool
.RE
.
.P
\(em
.P
.
Attach a cache to an LV, converts the LV to type cache.
.P
.B lvconvert
\fB--type\fP \fBcache\fP
\fB--cachevol\fP \fILV\fP
\fILV1\fP
.RS
[ \fB-H\fP|\fB--cache\fP ]
.br
[ \fB-Z\fP|\fB--zero\fP \fBy\fP|\fBn\fP ]
.br
[ \fB-c\fP|\fB--chunksize\fP \fISize\fP[k|\:UNIT] ]
.br
[ \0\0\0\fB--cachemetadataformat\fP \fBauto\fP|\fB1\fP|\fB2\fP ]
.br
[ \0\0\0\fB--cachemode\fP \%\fBwritethrough\fP|\:\c
\fBwriteback\fP|\:\c
\fBpassthrough\fP ]
.br
[ \0\0\0\fB--cachepolicy\fP \fIString\fP ]
.br
[ \0\0\0\fB--cachesettings\fP \fIString\fP ]
.br
[ \0\0\0\fB--poolmetadatasize\fP \fISize\fP[m|\:UNIT] ]
.br
[ COMMON_OPTIONS ]
.sp
LV1 types: linear striped raid thinpool
.RE
.
.P
\(em
.P
.
Add a writecache to an LV, using a specified cache device.
.P
.B lvconvert
\fB--type\fP \fBwritecache\fP
\fB--cachedevice\fP \fIPV\fP
\fILV1\fP
.RS
[ \0\0\0\fB--cachesize\fP \fISize\fP[m|\:UNIT] ]
.br
[ \0\0\0\fB--cachesettings\fP \fIString\fP ]
.br
[ COMMON_OPTIONS ]
.sp
LV1 types: linear striped raid thinpool
.RE
.
.P
\(em
.P
.
Add a cache to an LV, using a specified cache device.
.P
.B lvconvert
\fB--type\fP \fBcache\fP
\fB--cachedevice\fP \fIPV\fP
\fILV1\fP
.RS
[ \fB-c\fP|\fB--chunksize\fP \fISize\fP[k|\:UNIT] ]
.br
[ \0\0\0\fB--cachesize\fP \fISize\fP[m|\:UNIT] ]
.br
[ \0\0\0\fB--cachesettings\fP \fIString\fP ]
.br
[ COMMON_OPTIONS ]
.sp
LV1 types: linear striped raid thinpool
.RE
.
.P
\(em
.P
.
Convert LV to type thin-pool.
.P
.B lvconvert
\fB--type\fP \fBthin-pool\fP
\fILV1\fP
.RS
[ \fB-I\fP|\fB--stripesize\fP \fISize\fP[k|\:UNIT] ]
.br
[ \fB-c\fP|\fB--chunksize\fP \fISize\fP[k|\:UNIT] ]
.br
[ \fB-r\fP|\fB--readahead\fP \%\fBauto\fP|\:\c
\fBnone\fP|\:\c
\fINumber\fP ]
.br
[ \fB-W\fP|\fB--wipesignatures\fP \fBy\fP|\fBn\fP ]
.br
[ \fB-Z\fP|\fB--zero\fP \fBy\fP|\fBn\fP ]
.br
[ \0\0\0\fB--stripes\fP \fINumber\fP ]
.br
[ \0\0\0\fB--discards\fP \%\fBpassdown\fP|\:\c
\fBnopassdown\fP|\:\c
\fBignore\fP ]
.br
[ \0\0\0\fB--errorwhenfull\fP \fBy\fP|\fBn\fP ]
.br
[ \0\0\0\fB--pooldatavdo\fP \fBy\fP|\fBn\fP ]
.br
[ \0\0\0\fB--compression\fP \fBy\fP|\fBn\fP ]
.br
[ \0\0\0\fB--deduplication\fP \fBy\fP|\fBn\fP ]
.br
[ \0\0\0\fB--vdosettings\fP \fIString\fP ]
.br
[ \0\0\0\fB--poolmetadata\fP \fILV\fP ]
.br
[ \0\0\0\fB--poolmetadatasize\fP \fISize\fP[m|\:UNIT] ]
.br
[ \0\0\0\fB--poolmetadataspare\fP \fBy\fP|\fBn\fP ]
.br
[ \0\0\0\fB--metadataprofile\fP \fIString\fP ]
.br
[ COMMON_OPTIONS ]
.br
[ \fIPV\fP.\|.\|. ]
.sp
LV1 types: linear striped cache raid vdo writecache zero error
.RE
.
.P
\(em
.P
.
Convert LV to type cache-pool.
.P
.B lvconvert
\fB--type\fP \fBcache-pool\fP
\fILV1\fP
.RS
[ \fB-Z\fP|\fB--zero\fP \fBy\fP|\fBn\fP ]
.br
[ \fB-c\fP|\fB--chunksize\fP \fISize\fP[k|\:UNIT] ]
.br
[ \fB-r\fP|\fB--readahead\fP \%\fBauto\fP|\:\c
\fBnone\fP|\:\c
\fINumber\fP ]
.br
[ \fB-W\fP|\fB--wipesignatures\fP \fBy\fP|\fBn\fP ]
.br
[ \0\0\0\fB--cachemetadataformat\fP \fBauto\fP|\fB1\fP|\fB2\fP ]
.br
[ \0\0\0\fB--cachemode\fP \%\fBwritethrough\fP|\:\c
\fBwriteback\fP|\:\c
\fBpassthrough\fP ]
.br
[ \0\0\0\fB--cachepolicy\fP \fIString\fP ]
.br
[ \0\0\0\fB--cachesettings\fP \fIString\fP ]
.br
[ \0\0\0\fB--poolmetadata\fP \fILV\fP ]
.br
[ \0\0\0\fB--poolmetadatasize\fP \fISize\fP[m|\:UNIT] ]
.br
[ \0\0\0\fB--poolmetadataspare\fP \fBy\fP|\fBn\fP ]
.br
[ \0\0\0\fB--metadataprofile\fP \fIString\fP ]
.br
[ COMMON_OPTIONS ]
.br
[ \fIPV\fP.\|.\|. ]
.sp
LV1 types: linear striped raid zero error
.RE
.
.P
\(em
.P
.
Convert LV to type vdopool.
.P
.B lvconvert
\fB--type\fP \fBvdo-pool\fP
\fILV1\fP
.RS
[ \fB-n\fP|\fB--name\fP \fILV\fP\fI_new\fP ]
.br
[ \fB-V\fP|\fB--virtualsize\fP \fISize\fP[m|\:UNIT] ]
.br
[ \fB-r\fP|\fB--readahead\fP \%\fBauto\fP|\:\c
\fBnone\fP|\:\c
\fINumber\fP ]
.br
[ \fB-W\fP|\fB--wipesignatures\fP \fBy\fP|\fBn\fP ]
.br
[ \fB-Z\fP|\fB--zero\fP \fBy\fP|\fBn\fP ]
.br
[ \0\0\0\fB--compression\fP \fBy\fP|\fBn\fP ]
.br
[ \0\0\0\fB--deduplication\fP \fBy\fP|\fBn\fP ]
.br
[ \0\0\0\fB--vdosettings\fP \fIString\fP ]
.br
[ \0\0\0\fB--metadataprofile\fP \fIString\fP ]
.br
[ COMMON_OPTIONS ]
.sp
LV1 types: linear striped cache raid
.RE
.
.P
\(em
.P
.
Detach a cache from an LV.
.P
.B lvconvert
\fB--splitcache\fP
\fILV1\fP
.RS
[ \0\0\0\fB--cachesettings\fP \fIString\fP ]
.br
[ COMMON_OPTIONS ]
.sp
LV1 types: cache cachepool thinpool vdopool writecache
.RE
.
.P
\(em
.P
.
Merge thin LV into its origin LV.
.P
.B lvconvert
\fB--mergethin\fP
\fILV1\fP.\|.\|.
.RS
[ COMMON_OPTIONS ]
.sp
LV1 types: thin
.RE
.
.P
\(em
.P
.
Merge COW snapshot LV into its origin.
.P
.B lvconvert
\fB--mergesnapshot\fP
\fILV1\fP.\|.\|.
.RS
[ \fB-i\fP|\fB--interval\fP \fINumber\fP ]
.br
[ COMMON_OPTIONS ]
.sp
LV1 types: snapshot
.RE
.
.P
\(em
.P
.
Combine a former COW snapshot (second arg) with a former
origin LV (first arg) to reverse a splitsnapshot command.
.P
.B lvconvert
\fB--type\fP \fBsnapshot\fP
\fILV\fP \fILV1\fP
.RS
[ \fB-s\fP|\fB--snapshot\fP ]
.br
[ \fB-c\fP|\fB--chunksize\fP \fISize\fP[k|\:UNIT] ]
.br
[ \fB-Z\fP|\fB--zero\fP \fBy\fP|\fBn\fP ]
.br
[ COMMON_OPTIONS ]
.sp
LV1 types: linear striped
.RE
.
.P
\(em
.P
.
Replace failed PVs in a raid or mirror LV.
Repair a thin pool.
Repair a cache pool.
.P
.B lvconvert
\fB--repair\fP
\fILV1\fP
.RS
[ \fB-i\fP|\fB--interval\fP \fINumber\fP ]
.br
[ \fB-k\fP|\fB--setactivationskip\fP \fBy\fP|\fBn\fP ]
.br
[ \0\0\0\fB--usepolicies\fP ]
.br
[ \0\0\0\fB--poolmetadataspare\fP \fBy\fP|\fBn\fP ]
.br
[ COMMON_OPTIONS ]
.br
[ \fIPV\fP.\|.\|. ]
.sp
LV1 types: cache cachepool mirror raid thinpool
.RE
.
.P
\(em
.P
.
Replace specific PV(s) in a raid LV with another PV.
.P
.B lvconvert
\fB--replace\fP \fIPV\fP
\fILV1\fP
.RS
[ COMMON_OPTIONS ]
.br
[ \fIPV\fP.\|.\|. ]
.sp
LV1 types: raid
.RE
.
.P
\(em
.P
.
Poll LV to continue conversion.
.P
.B lvconvert
\fB--startpoll\fP
\fILV1\fP
.RS
[ COMMON_OPTIONS ]
.sp
LV1 types: mirror raid
.RE
.
.P
\(em
.P
.
Add or remove data integrity checksums to raid images.
.P
.B lvconvert
\fB--raidintegrity\fP \fBy\fP|\fBn\fP
\fILV1\fP
.RS
[ \0\0\0\fB--raidintegritymode\fP \fIString\fP ]
.br
[ \0\0\0\fB--raidintegrityblocksize\fP \fINumber\fP ]
.br
[ \0\0\0\fB--integritysettings\fP \fIString\fP ]
.br
[ COMMON_OPTIONS ]
.br
[ \fIPV\fP.\|.\|. ]
.sp
LV1 types: raid
.RE
.P
\(em
.P
Common options for command:
.RS
[ \fB-b\fP|\fB--background\fP ]
.br
[ \fB-f\fP|\fB--force\fP ]
.br
[ \0\0\0\fB--alloc\fP \%\fBcontiguous\fP|\:\c
\fBcling\fP|\:\c
\fBcling_by_tags\fP|\:\c
\fBnormal\fP|\:\c
\fBanywhere\fP|\:\c
\fBinherit\fP ]
.br
[ \0\0\0\fB--noudevsync\fP ]
.RE
.P
Common options for lvm:
.RS
[ \fB-d\fP|\fB--debug\fP ]
.br
[ \fB-h\fP|\fB--help\fP ]
.br
[ \fB-q\fP|\fB--quiet\fP ]
.br
[ \fB-t\fP|\fB--test\fP ]
.br
[ \fB-v\fP|\fB--verbose\fP ]
.br
[ \fB-y\fP|\fB--yes\fP ]
.br
[ \0\0\0\fB--commandprofile\fP \fIString\fP ]
.br
[ \0\0\0\fB--config\fP \fIString\fP ]
.br
[ \0\0\0\fB--devices\fP \fIPV\fP ]
.br
[ \0\0\0\fB--devicesfile\fP \fIString\fP ]
.br
[ \0\0\0\fB--driverloaded\fP \fBy\fP|\fBn\fP ]
.br
[ \0\0\0\fB--journal\fP \fIString\fP ]
.br
[ \0\0\0\fB--lockopt\fP \fIString\fP ]
.br
[ \0\0\0\fB--longhelp\fP ]
.br
[ \0\0\0\fB--nohints\fP ]
.br
[ \0\0\0\fB--nolocking\fP ]
.br
[ \0\0\0\fB--profile\fP \fIString\fP ]
.br
[ \0\0\0\fB--version\fP ]
.RE
.hy
.ad
.
.SH OPTIONS
.
.TP
\fB--alloc\fP \%\fBcontiguous\fP|\:\c
\fBcling\fP|\:\c
\fBcling_by_tags\fP|\:\c
\fBnormal\fP|\:\c
\fBanywhere\fP|\:\c
\fBinherit\fP
Determines the allocation policy when a command needs to allocate
Physical Extents (PEs) from the VG. Each VG and LV has an allocation policy
which can be changed with vgchange/lvchange, or overridden on the
command line.
\fBnormal\fP applies common sense rules such as not placing parallel stripes
on the same PV.
\fBinherit\fP applies the VG policy to an LV.
\fBcontiguous\fP requires new PEs be placed adjacent to existing PEs.
\fBcling\fP places new PEs on the same PV as existing PEs in the same
stripe of the LV.
If there are sufficient PEs for an allocation, but normal does not
use them, \fBanywhere\fP will use them even if it reduces performance,
e.g. by placing two stripes on the same PV.
Optional positional PV args on the command line can also be used to limit
which PVs the command will use for allocation.
See \fBlvm\fP(8) for more information about allocation.
.
.TP
\fB-b\fP|\fB--background\fP
If the operation requires polling, this option causes the command to
return before the operation is complete, and polling is done in the
background.
.
.TP
\fB-H\fP|\fB--cache\fP
Specifies the command is handling a cache LV or cache pool.
See --type cache and --type cache-pool.
See \fBlvmcache\fP(7) for more information about LVM caching.
.
.TP
\fB--cachedevice\fP \fIPV\fP
The name of a device to use for a cache.
.
.TP
\fB--cachemetadataformat\fP \fBauto\fP|\fB1\fP|\fB2\fP
Specifies the cache metadata format used by cache target.
.
.TP
\fB--cachemode\fP \%\fBwritethrough\fP|\:\c
\fBwriteback\fP|\:\c
\fBpassthrough\fP
Specifies when writes to a cache LV should be considered complete.
\fBwriteback\fP considers a write complete as soon as it is
stored in the cache pool.
\fBwritethough\fP considers a write complete only when it has
been stored in both the cache pool and on the origin LV.
While writethrough may be slower for writes, it is more
resilient if something should happen to a device associated with the
cache pool LV. With \fBpassthrough\fP, all reads are served
from the origin LV (all reads miss the cache) and all writes are
forwarded to the origin LV; additionally, write hits cause cache
block invalidates. See \fBlvmcache\fP(7) for more information.
.
.TP
\fB--cachepolicy\fP \fIString\fP
Specifies the cache policy for a cache LV.
See \fBlvmcache\fP(7) for more information.
.
.TP
\fB--cachepool\fP \fILV\fP
The name of a cache pool.
.
.TP
\fB--cachesettings\fP \fIString\fP
Specifies tunable kernel options for dm-cache or dm-writecache LVs.
Use the form 'option=value' or 'option1=value option2=value', or
repeat --cachesettings for each option being set.
These settings override the default kernel behaviors which are
usually adequate. To remove cachesettings and revert to the default
kernel behaviors, use --cachesettings 'default' for dm-cache or
an empty string --cachesettings '' for dm-writecache.
See \fBlvmcache\fP(7) for more information.
.
.TP
\fB--cachesize\fP \fISize\fP[m|\:UNIT]
The size of cache to use.
.
.TP
\fB--cachevol\fP \fILV\fP
The name of a cache volume.
.
.TP
\fB-c\fP|\fB--chunksize\fP \fISize\fP[k|\:UNIT]
The size of chunks in a snapshot, cache pool or thin pool.
For snapshots, the value must be a power of 2 between 4 KiB and 512 KiB
and the default value is 4.
For a cache pool the value must be between 32 KiB and 1 GiB
and the default value is 64.
For a thin pool the value must be between 64 KiB and 1 GiB
and the default value starts with 64 and scales up to fit the
pool metadata size within 128 MiB, if the pool metadata size is not specified.
The value must be a multiple of 64 KiB.
See \fBlvmthin\fP(7) and \fBlvmcache\fP(7) for more information.
.
.TP
\fB--commandprofile\fP \fIString\fP
The command profile to use for command configuration.
See \fBlvm.conf\fP(5) for more information about profiles.
.
.TP
\fB--compression\fP \fBy\fP|\fBn\fP
Controls whether compression is enabled or disable for VDO volume.
See \fBlvmvdo\fP(7) for more information about VDO usage.
.
.TP
\fB--config\fP \fIString\fP
Config settings for the command. These override \fBlvm.conf\fP(5) settings.
The String arg uses the same format as \fBlvm.conf\fP(5),
or may use section/field syntax.
See \fBlvm.conf\fP(5) for more information about config.
.
.TP
\fB-d\fP|\fB--debug\fP.\|.\|.
Set debug level. Repeat from 1 to 6 times to increase the detail of
messages sent to the log file and/or syslog (if configured).
.
.TP
\fB--deduplication\fP \fBy\fP|\fBn\fP
Controls whether deduplication is enabled or disable for VDO volume.
See \fBlvmvdo\fP(7) for more information about VDO usage.
.
.TP
\fB--devices\fP \fIPV\fP
Restricts the devices that are visible and accessible to the command.
Devices not listed will appear to be missing. This option can be
repeated, or accepts a comma separated list of devices. This overrides
the devices file.
.
.TP
\fB--devicesfile\fP \fIString\fP
A file listing devices that LVM should use.
The file must exist in \fI#DEFAULT_SYS_DIR#/devices/\fP and is managed
with the \fBlvmdevices\fP(8) command.
This overrides the \fBlvm.conf\fP(5) \fBdevices/devicesfile\fP and
\fBdevices/use_devicesfile\fP settings.
.
.TP
\fB--discards\fP \%\fBpassdown\fP|\:\c
\fBnopassdown\fP|\:\c
\fBignore\fP
Specifies how the device-mapper thin pool layer in the kernel should
handle discards.
\fBignore\fP causes the thin pool to ignore discards.
\fBnopassdown\fP causes the thin pool to process discards itself to
allow reuse of unneeded extents in the thin pool.
\fBpassdown\fP causes the thin pool to process discards itself
(like nopassdown) and pass the discards to the underlying device.
See \fBlvmthin\fP(7) for more information.
.
.TP
\fB--driverloaded\fP \fBy\fP|\fBn\fP
If set to no, the command will not attempt to use device-mapper.
For testing and debugging.
.
.TP
\fB--errorwhenfull\fP \fBy\fP|\fBn\fP
Specifies thin pool behavior when data space is exhausted.
When yes, device-mapper will immediately return an error
when a thin pool is full and an I/O request requires space.
When no, device-mapper will queue these I/O requests for a
period of time to allow the thin pool to be extended.
Errors are returned if no space is available after the timeout.
(Also see dm-thin-pool kernel module option no_space_timeout.)
See \fBlvmthin\fP(7) for more information.
.
.TP
\fB-f\fP|\fB--force\fP.\|.\|.
Override various checks, confirmations and protections.
Use with extreme caution.
.
.TP
\fB-h\fP|\fB--help\fP
Display help text.
.
.TP
\fB--integritysettings\fP \fIString\fP
Specifies tunable kernel options for dm-integrity.
See \fBlvmraid\fP(7) for more information.
.
.TP
\fB-i\fP|\fB--interval\fP \fINumber\fP
Report progress at regular intervals.
.
.TP
\fB--journal\fP \fIString\fP
Record information in the systemd journal.
This information is in addition to information
enabled by the lvm.conf log/journal setting.
command: record information about the command.
output: record the default command output.
debug: record full command debugging.
.
.TP
\fB--lockopt\fP \fIString\fP
Used to pass options for special cases to lvmlockd.
See \fBlvmlockd\fP(8) for more information.
.
.TP
\fB--longhelp\fP
Display long help text.
.
.TP
\fB--merge\fP
An alias for --mergethin, --mergemirrors, or --mergesnapshot,
depending on the type of LV.
.
.TP
\fB--mergemirrors\fP
Merge LV images that were split from a raid1 LV.
See --splitmirrors with --trackchanges.
.
.TP
\fB--mergesnapshot\fP
Merge COW snapshot LV into its origin.
When merging a snapshot, if both the origin and snapshot LVs are not open,
the merge will start immediately. Otherwise, the merge will start the
first time either the origin or snapshot LV are activated and both are
closed. Merging a snapshot into an origin that cannot be closed, for
example a root filesystem, is deferred until the next time the origin
volume is activated. When merging starts, the resulting LV will have the
origin's name, minor number and UUID. While the merge is in progress,
reads or writes to the origin appear as being directed to the snapshot
being merged. When the merge finishes, the merged snapshot is removed.
Multiple snapshots may be specified on the command line or a @tag may be
used to specify multiple snapshots be merged to their respective origin.
.
.TP
\fB--mergethin\fP
Merge thin LV into its origin LV.
The origin thin LV takes the content of the thin snapshot,
and the thin snapshot LV is removed.
See \fBlvmthin\fP(7) for more information.
.
.TP
\fB--metadataprofile\fP \fIString\fP
The metadata profile to use for command configuration.
See \fBlvm.conf\fP(5) for more information about profiles.
.
.TP
\fB--mirrorlog\fP \fBcore\fP|\fBdisk\fP
Specifies the type of mirror log for LVs with the "mirror" type
(does not apply to the "raid1" type.)
\fBdisk\fP is a persistent log and requires a small amount of
storage space, usually on a separate device from the data being mirrored.
\fBcore\fP is not persistent; the log is kept only in memory.
In this case, the mirror must be synchronized (by copying LV data from
the first device to others) each time the LV is activated, e.g. after reboot.
\fBmirrored\fP is a persistent log that is itself mirrored, but
should be avoided. Instead, use the raid1 type for log redundancy.
.
.TP
\fB-m\fP|\fB--mirrors\fP [\fB+\fP|\fB-\fP]\fINumber\fP
Specifies the number of mirror images in addition to the original LV
image, e.g. --mirrors 1 means there are two images of the data, the
original and one mirror image.
Optional positional PV args on the command line can specify the devices
the images should be placed on.
There are two mirroring implementations: "raid1" and "mirror".
These are the names of the corresponding LV types, or "segment types".
Use the --type option to specify which to use (raid1 is default,
and mirror is legacy)
Use \fBlvm.conf\fP(5) \fBglobal/mirror_segtype_default\fP and
global/raid10_segtype_default to configure the default types.
The plus prefix \fB+\fP can be used, in which case
the number is added to the current number of images,
or the minus prefix \fB-\fP can be used, in which case
the number is subtracted from the current number of images.
See \fBlvmraid\fP(7) for more information.
.
.TP
\fB-n\fP|\fB--name\fP \fIString\fP
Specifies the name of a new LV.
When unspecified, a default name of "lvol#" is
generated, where # is a number generated by LVM.
.
.TP
\fB--nohints\fP
Do not use the hints file to locate devices for PVs. A command may read
more devices to find PVs when hints are not used. The command will still
perform standard hint file invalidation where appropriate.
.
.TP
\fB--nolocking\fP
Disable locking. Use with caution, concurrent commands may produce
incorrect results.
.
.TP
\fB--noudevsync\fP
Disables udev synchronization. The process will not wait for notification
from udev. It will continue irrespective of any possible udev processing
in the background. Only use this if udev is not running or has rules that
ignore the devices LVM creates.
.
.TP
\fB--originname\fP \fILV\fP
Specifies the name to use for the external origin LV when converting an LV
to a thin LV. The LV being converted becomes a read-only external origin
with this name.
.
.TP
\fB--pooldatavdo\fP \fBy\fP|\fBn\fP
Use VDO type volume for pool data volume.
.
.TP
\fB--poolmetadata\fP \fILV\fP
The name of a an LV to use for storing pool metadata.
.
.TP
\fB--poolmetadatasize\fP \fISize\fP[m|\:UNIT]
Specifies the size of the new pool metadata LV.
.
.TP
\fB--poolmetadataspare\fP \fBy\fP|\fBn\fP
Enable or disable the automatic creation and management of a
spare pool metadata LV in the VG. A spare metadata LV is reserved
space that can be used when repairing a pool.
.
.TP
\fB--profile\fP \fIString\fP
An alias for --commandprofile or --metadataprofile, depending
on the command.
.
.TP
\fB-q\fP|\fB--quiet\fP.\|.\|.
Suppress output and log messages. Overrides --debug and --verbose.
Repeat once to also suppress any prompts with answer 'no'.
.
.TP
\fB--raidintegrity\fP \fBy\fP|\fBn\fP
Enable or disable data integrity checksums for raid images.
.
.TP
\fB--raidintegrityblocksize\fP \fINumber\fP
The block size to use for dm-integrity on raid images.
The integrity block size should usually match the device
logical block size, or the file system block size.
It may be less than the file system block size, but not
less than the device logical block size.
Possible values: 512, 1024, 2048, 4096.
.
.TP
\fB--raidintegritymode\fP \fIString\fP
Use a journal (default) or bitmap for keeping integrity checksums consistent
in case of a crash. The bitmap areas are recalculated after a crash,
so corruption in those areas would not be detected.
A journal does not have this problem.
The journal mode doubles writes to storage, but can improve performance for
scattered writes packed into a single journal write.
bitmap mode can in theory achieve full write throughput of the device,
but would not benefit from the potential scattered write optimization.
.
.TP
\fB-r\fP|\fB--readahead\fP \%\fBauto\fP|\:\c
\fBnone\fP|\:\c
\fINumber\fP
Sets read ahead sector count of an LV.
\fBauto\fP is the default which allows the kernel to choose
a suitable value automatically.
\fBnone\fP is equivalent to zero.
.
.TP
\fB-R\fP|\fB--regionsize\fP \fISize\fP[m|\:UNIT]
Size of each raid or mirror synchronization region.
\fBlvm.conf\fP(5) \fBactivation/raid_region_size\fP can be used to
configure a default.
.
.TP
\fB--repair\fP
Replace failed PVs in a raid or mirror LV, or run a repair
utility on a thin pool. See \fBlvmraid\fP(7) and \fBlvmthin\fP(7)
for more information.
.
.TP
\fB--replace\fP \fIPV\fP
Replace a specific PV in a raid LV with another PV.
The new PV to use can be optionally specified after the LV.
Multiple PVs can be replaced by repeating this option.
See \fBlvmraid\fP(7) for more information.
.
.TP
\fB-k\fP|\fB--setactivationskip\fP \fBy\fP|\fBn\fP
Persistently sets (yes) or clears (no) the "activation skip" flag on an LV.
An LV with this flag set is not activated unless the
--ignoreactivationskip option is used by the activation command.
This flag is set by default on new thin snapshot LVs.
The flag is not applied to deactivation.
The current value of the flag is indicated in the lvs lv_attr bits.
.
.TP
\fB-s\fP|\fB--snapshot\fP
Combine a former COW snapshot LV with a former origin LV to reverse
a previous --splitsnapshot command.
.
.TP
\fB--splitcache\fP
Separates a cache pool from a cache LV, and keeps the unused cache pool LV.
Before the separation, the cache is flushed. Also see --uncache.
.
.TP
\fB--splitmirrors\fP \fINumber\fP
Splits the specified number of images from a raid1 or mirror LV
and uses them to create a new LV. If --trackchanges is also specified,
changes to the raid1 LV are tracked while the split LV remains detached.
If --name is specified, then the images are permanently split from the
original LV and changes are not tracked.
.
.TP
\fB--splitsnapshot\fP
Separates a COW snapshot from its origin LV. The LV that is split off
contains the chunks that differ from the origin LV along with metadata
describing them. This LV can be wiped and then destroyed with lvremove.
.
.TP
\fB--startpoll\fP
Start polling an LV to continue processing a conversion.
.
.TP
\fB--stripes\fP \fINumber\fP
Specifies the number of stripes in a striped LV. This is the number of
PVs (devices) that a striped LV is spread across. Data that
appears sequential in the LV is spread across multiple devices in units of
the stripe size (see --stripesize). This does not apply to
existing allocated space, only newly allocated space can be striped.
.
.TP
\fB-I\fP|\fB--stripesize\fP \fISize\fP[k|\:UNIT]
The amount of data that is written to one device before
moving to the next in a striped LV.
.
.TP
\fB--swapmetadata\fP
Extracts the metadata LV from a pool and replaces it with another specified LV.
The extracted LV is preserved and given the name of the LV that replaced it.
Use for repair only. When the metadata LV is swapped out of the pool, it can
be activated directly and used with thin provisioning tools:
\fBcache_dump\fP(8), \fBcache_repair\fP(8), \fBcache_restore\fP(8),
\fBthin_dump\fP(8), \fBthin_repair\fP(8), \fBthin_restore\fP(8).
.
.TP
\fB-t\fP|\fB--test\fP
Run in test mode. Commands will not update metadata.
This is implemented by disabling all metadata writing but nevertheless
returning success to the calling function. This may lead to unusual
error messages in multi-stage operations if a tool relies on reading
back metadata it believes has changed but hasn't.
.
.TP
\fB-T\fP|\fB--thin\fP
Specifies the command is handling a thin LV or thin pool.
See --type thin, --type thin-pool, and --virtualsize.
See \fBlvmthin\fP(7) for more information about LVM thin provisioning.
.
.TP
\fB--thinpool\fP \fILV\fP
The name of a thin pool LV.
.
.TP
\fB--trackchanges\fP
Can be used with --splitmirrors on a raid1 LV. This causes
changes to the original raid1 LV to be tracked while the split images
remain detached. This is a temporary state that allows the read-only
detached image to be merged efficiently back into the raid1 LV later.
Only the regions with changed data are resynchronized during merge.
While a raid1 LV is tracking changes, operations on it are limited to
merging the split image (see --mergemirrors) or permanently splitting
the image (see --splitmirrors with --name.
.
.TP
\fB--type\fP \%\fBlinear\fP|\:\c
\fBstriped\fP|\:\c
\fBsnapshot\fP|\:\c
\fBraid\fP|\:\c
\fBmirror\fP|\:\c
\fBthin\fP|\:\c
\fBthin-pool\fP|\:\c
\fBvdo\fP|\:\c
\fBvdo-pool\fP|\:\c
\fBcache\fP|\:\c
\fBcache-pool\fP|\:\c
\fBwritecache\fP
The LV type, also known as "segment type" or "segtype".
See usage descriptions for the specific ways to use these types.
For more information about redundancy and performance
(\fBraid\fP<N>, \fBmirror\fP, \fBstriped\fP, \fBlinear\fP)
see \fBlvmraid\fP(7).
For thin provisioning (\fBthin\fP, \fBthin-pool\fP) see \fBlvmthin\fP(7).
For performance caching (\fBcache\fP, \fBcache-pool\fP) see \fBlvmcache\fP(7).
For copy-on-write snapshots (\fBsnapshot\fP) see usage definitions.
For VDO (\fBvdo\fP) see \fBlvmvdo\fP(7).
Several commands omit an explicit type option because the type
is inferred from other options or shortcuts
(e.g. --stripes, --mirrors, --snapshot, --virtualsize,
--thin, --cache, --vdo).
Use inferred types with care because it can lead to unexpected results.
.
.TP
\fB--uncache\fP
Separates a cache pool from a cache LV, and deletes the unused cache pool LV.
Before the separation, the cache is flushed. Also see --splitcache.
.
.TP
\fB--usepolicies\fP
Perform an operation according to the policy configured in \fBlvm.conf\fP(5)
or a profile.
.
.TP
\fB--vdopool\fP \fILV\fP
The name of a VDO pool LV.
See \fBlvmvdo\fP(7) for more information about VDO usage.
.
.TP
\fB--vdosettings\fP \fIString\fP
Specifies tunable VDO options for VDO LVs.
Use the form 'option=value' or 'option1=value option2=value', or
repeat --vdosettings for each option being set.
These settings override the default VDO behaviors.
To remove vdosettings and revert to the default
VDO behaviors, use --vdosettings 'default'.
See \fBlvmvdo\fP(7) for more information.
.
.TP
\fB-v\fP|\fB--verbose\fP.\|.\|.
Set verbose level. Repeat from 1 to 4 times to increase the detail
of messages sent to stdout and stderr.
.
.TP
\fB--version\fP
Display version information.
.
.TP
\fB-V\fP|\fB--virtualsize\fP \fISize\fP[m|\:UNIT]
The virtual size of a new thin LV.
See \fBlvmthin\fP(7) for more information about LVM thin provisioning.
Using virtual size (-V) and actual size (-L) together creates
a sparse LV.
\fBlvm.conf\fP(5) \fBglobal/sparse_segtype_default\fP determines the
default segment type used to create a sparse LV.
Anything written to a sparse LV will be returned when reading from it.
Reading from other areas of the LV will return blocks of zeros.
When using a snapshot to create a sparse LV, a hidden virtual device
is created using the zero target, and the LV has the suffix _vorigin.
Snapshots are less efficient than thin provisioning when creating
large sparse LVs (GiB).
.
.TP
\fB-W\fP|\fB--wipesignatures\fP \fBy\fP|\fBn\fP
Controls detection and subsequent wiping of signatures on new LVs.
There is a prompt for each signature detected to confirm its wiping
(unless --yes is used to override confirmations.)
When not specified, signatures are wiped whenever zeroing is done
(see --zero). This behaviour can be configured with
\fBlvm.conf\fP(5) \fBallocation/wipe_signatures_when_zeroing_new_lvs\fP.
If blkid wiping is used (\fBlvm.conf\fP(5) \fBallocation/use_blkid_wiping\fP)
and LVM is compiled with blkid wiping support, then the blkid(8)
library is used to detect the signatures (use blkid -k to list the
signatures that are recognized).
Otherwise, native LVM code is used to detect signatures
(only MD RAID, swap and LUKS signatures are detected in this case.)
The LV is not wiped if the read only flag is set.
.
.TP
\fB-y\fP|\fB--yes\fP
Do not prompt for confirmation interactively but always assume the
answer yes. Use with extreme caution.
(For automatic no, see -qq.)
.
.TP
\fB-Z\fP|\fB--zero\fP \fBy\fP|\fBn\fP
For snapshots, this controls zeroing of the first 4 KiB of data in the
snapshot. If the LV is read-only, the snapshot will not be zeroed.
For thin pools, this controls zeroing of provisioned blocks.
Provisioning of large zeroed chunks negatively impacts performance.
.
.SH VARIABLES
.
.TP
.I VG
Volume Group name.  See \fBlvm\fP(8) for valid names.
.
.TP
.I LV
Logical Volume name.  See \fBlvm\fP(8) for valid names.
An LV positional arg generally includes the VG name and LV name, e.g. VG/LV.
LV1 indicates the LV must have a specific type, where the
accepted LV types are listed. (raid represents raid<N> type).
.
.TP
.I PV
Physical Volume name, a device path under /dev.
For commands managing physical extents, a PV positional arg
generally accepts a suffix indicating a range (or multiple ranges)
of physical extents (PEs). When the first PE is omitted, it defaults
to the start of the device, and when the last PE is omitted it defaults to end.
Start and end range (inclusive):
\fIPV\fP[\fB:\fP\fIPE\fP\fB-\fP\fIPE\fP].\|.\|.
Start and length range (counting from 0):
\fIPV\fP[\fB:\fP\fIPE\fP\fB+\fP\fIPE\fP].\|.\|.
.
.TP
.I Tag
Tag name.  See \fBlvm\fP(8) for information about tag names and using tags
in place of a VG, LV or PV.
.
.TP
.I String
See the option description for information about the string content.
.
.TP
.IR Size [UNIT]
Size is an input number that accepts an optional unit.
Input units are always treated as base two values, regardless of
capitalization, e.g. 'k' and 'K' both refer to 1024.
The default input unit is specified by letter, followed by |UNIT.
UNIT represents other possible input units:
.BR b | B
is bytes,
.BR s | S
is sectors of 512 bytes,
.BR k | K
is KiB,
.BR m | M
is MiB,
.BR g | G
is GiB,
.BR t | T
is TiB,
.BR p | P
is PiB,
.BR e | E
is EiB.
(This should not be confused with the output control --units,
where capital letters mean multiple of 1000.)
.
.SH ENVIRONMENT VARIABLES
.
See \fBlvm\fP(8) for information about environment variables used by lvm.
For example, \fBLVM_VG_NAME\fP can generally be substituted
for a required VG parameter.
.
.SH ADVANCED USAGE
.
Alternate command forms, advanced command usage,
and listing of all valid syntax for completeness.
.P
Change the region size of an LV.
.P
.B lvconvert
\fB-R\fP|\fB--regionsize\fP \fISize\fP[m|\:UNIT]
\fILV1\fP
.RS
[ COMMON_OPTIONS ]
.sp
LV1 types: raid
.RE
.
.P
\(em
.P
.
Change the type of mirror log used by a mirror LV.
.P
.B lvconvert
\fB--mirrorlog\fP \fBcore\fP|\fBdisk\fP
\fILV1\fP
.RS
[ COMMON_OPTIONS ]
.br
[ \fIPV\fP.\|.\|. ]
.sp
LV1 types: mirror
.RE
.
.P
\(em
.P
.
Convert LV to a thin LV, using the original LV as an external origin.
.P
.B lvconvert
\fB-T\fP|\fB--thin\fP
\fB--thinpool\fP \fILV\fP
\fILV1\fP
.RS
[ \fB--type thin\fP ] (implied)
.br
[ \fB-c\fP|\fB--chunksize\fP \fISize\fP[k|\:UNIT] ]
.br
[ \fB-r\fP|\fB--readahead\fP \%\fBauto\fP|\:\c
\fBnone\fP|\:\c
\fINumber\fP ]
.br
[ \fB-W\fP|\fB--wipesignatures\fP \fBy\fP|\fBn\fP ]
.br
[ \fB-Z\fP|\fB--zero\fP \fBy\fP|\fBn\fP ]
.br
[ \0\0\0\fB--originname\fP \fILV\fP\fI_new\fP ]
.br
[ \0\0\0\fB--poolmetadata\fP \fILV\fP ]
.br
[ \0\0\0\fB--poolmetadatasize\fP \fISize\fP[m|\:UNIT] ]
.br
[ \0\0\0\fB--poolmetadataspare\fP \fBy\fP|\fBn\fP ]
.br
[ \0\0\0\fB--metadataprofile\fP \fIString\fP ]
.br
[ COMMON_OPTIONS ]
.br
[ \fIPV\fP.\|.\|. ]
.sp
LV1 types: linear striped cache raid thin zero error
.RE
.
.P
\(em
.P
.
Convert LV to a thin LV, using LV as thin-pool data volume.
.P
.B lvconvert
\fB-T\fP|\fB--thin\fP
\fILV1\fP
.RS
[ \fB--type thin\fP ] (implied)
.br
[ \fB-c\fP|\fB--chunksize\fP \fISize\fP[k|\:UNIT] ]
.br
[ \fB-r\fP|\fB--readahead\fP \%\fBauto\fP|\:\c
\fBnone\fP|\:\c
\fINumber\fP ]
.br
[ \fB-W\fP|\fB--wipesignatures\fP \fBy\fP|\fBn\fP ]
.br
[ \fB-Z\fP|\fB--zero\fP \fBy\fP|\fBn\fP ]
.br
[ \0\0\0\fB--poolmetadata\fP \fILV\fP ]
.br
[ \0\0\0\fB--poolmetadatasize\fP \fISize\fP[m|\:UNIT] ]
.br
[ \0\0\0\fB--poolmetadataspare\fP \fBy\fP|\fBn\fP ]
.br
[ \0\0\0\fB--metadataprofile\fP \fIString\fP ]
.br
[ COMMON_OPTIONS ]
.br
[ \fIPV\fP.\|.\|. ]
.sp
LV1 types: linear striped cache raid vdo writecache zero error
.RE
.
.P
\(em
.P
.
Attach a cache pool to an LV.
.P
.B lvconvert
\fB-H\fP|\fB--cache\fP
\fB--cachepool\fP \fILV\fP
\fILV1\fP
.RS
[ \fB--type cache\fP ] (implied)
.br
[ \fB-Z\fP|\fB--zero\fP \fBy\fP|\fBn\fP ]
.br
[ \fB-c\fP|\fB--chunksize\fP \fISize\fP[k|\:UNIT] ]
.br
[ \fB-r\fP|\fB--readahead\fP \%\fBauto\fP|\:\c
\fBnone\fP|\:\c
\fINumber\fP ]
.br
[ \fB-W\fP|\fB--wipesignatures\fP \fBy\fP|\fBn\fP ]
.br
[ \0\0\0\fB--cachemetadataformat\fP \fBauto\fP|\fB1\fP|\fB2\fP ]
.br
[ \0\0\0\fB--cachemode\fP \%\fBwritethrough\fP|\:\c
\fBwriteback\fP|\:\c
\fBpassthrough\fP ]
.br
[ \0\0\0\fB--cachepolicy\fP \fIString\fP ]
.br
[ \0\0\0\fB--cachesettings\fP \fIString\fP ]
.br
[ \0\0\0\fB--poolmetadata\fP \fILV\fP ]
.br
[ \0\0\0\fB--poolmetadatasize\fP \fISize\fP[m|\:UNIT] ]
.br
[ \0\0\0\fB--poolmetadataspare\fP \fBy\fP|\fBn\fP ]
.br
[ \0\0\0\fB--metadataprofile\fP \fIString\fP ]
.br
[ COMMON_OPTIONS ]
.br
[ \fIPV\fP.\|.\|. ]
.sp
LV1 types: linear striped raid thin thinpool vdo vdopool vdopooldata zero error
.RE
.
.P
\(em
.P
.
Attach a cache to an LV, converts the LV to type cache.
.P
.B lvconvert
\fB-H\fP|\fB--cache\fP
\fB--cachevol\fP \fILV\fP
\fILV1\fP
.RS
[ \fB-Z\fP|\fB--zero\fP \fBy\fP|\fBn\fP ]
.br
[ \fB-c\fP|\fB--chunksize\fP \fISize\fP[k|\:UNIT] ]
.br
[ \0\0\0\fB--cachemetadataformat\fP \fBauto\fP|\fB1\fP|\fB2\fP ]
.br
[ \0\0\0\fB--cachemode\fP \%\fBwritethrough\fP|\:\c
\fBwriteback\fP|\:\c
\fBpassthrough\fP ]
.br
[ \0\0\0\fB--cachepolicy\fP \fIString\fP ]
.br
[ \0\0\0\fB--cachesettings\fP \fIString\fP ]
.br
[ \0\0\0\fB--poolmetadatasize\fP \fISize\fP[m|\:UNIT] ]
.br
[ COMMON_OPTIONS ]
.sp
LV1 types: linear striped raid thinpool
.RE
.
.P
\(em
.P
.
Convert LV to type vdopool.
.P
.B lvconvert
\fB--vdopool\fP \fILV\fP
.RS
[ \fB--type vdo-pool\fP ] (implied)
.br
[ \fB-r\fP|\fB--readahead\fP \%\fBauto\fP|\:\c
\fBnone\fP|\:\c
\fINumber\fP ]
.br
[ \fB-W\fP|\fB--wipesignatures\fP \fBy\fP|\fBn\fP ]
.br
[ \fB-Z\fP|\fB--zero\fP \fBy\fP|\fBn\fP ]
.br
[ \fB-n\fP|\fB--name\fP \fILV\fP\fI_new\fP ]
.br
[ \fB-V\fP|\fB--virtualsize\fP \fISize\fP[m|\:UNIT] ]
.br
[ \0\0\0\fB--compression\fP \fBy\fP|\fBn\fP ]
.br
[ \0\0\0\fB--deduplication\fP \fBy\fP|\fBn\fP ]
.br
[ \0\0\0\fB--vdosettings\fP \fIString\fP ]
.br
[ \0\0\0\fB--metadataprofile\fP \fIString\fP ]
.br
[ COMMON_OPTIONS ]
.RE
.
.P
\(em
.P
.
Detach and delete a cache from an LV.
.P
.B lvconvert
\fB--uncache\fP
\fILV1\fP
.RS
[ \0\0\0\fB--cachesettings\fP \fIString\fP ]
.br
[ COMMON_OPTIONS ]
.sp
LV1 types: cache thinpool vdopool writecache
.RE
.
.P
\(em
.P
.
Swap metadata LV in a thin pool or cache pool (for repair only).
.P
.B lvconvert
\fB--swapmetadata\fP
\fB--poolmetadata\fP \fILV\fP
\fILV1\fP
.RS
[ \fB-c\fP|\fB--chunksize\fP \fISize\fP[k|\:UNIT] ]
.br
[ COMMON_OPTIONS ]
.sp
LV1 types: cachepool thinpool
.RE
.
.P
\(em
.P
.
Merge LV that was split from a mirror (variant, use --mergemirrors).
Merge thin LV into its origin LV (variant, use --mergethin).
Merge COW snapshot LV into its origin (variant, use --mergesnapshot).
.P
.B lvconvert
\fB--merge\fP
\fIVG\fP|\fILV1\fP|\fITag\fP.\|.\|.
.RS
[ \fB-i\fP|\fB--interval\fP \fINumber\fP ]
.br
[ COMMON_OPTIONS ]
.sp
LV1 types: linear striped snapshot raid thin
.RE
.
.P
\(em
.P
.
Separate a COW snapshot from its origin LV.
.P
.B lvconvert
\fB--splitsnapshot\fP
\fILV1\fP
.RS
[ COMMON_OPTIONS ]
.sp
LV1 types: snapshot
.RE
.
.P
\(em
.P
.
Combine a former COW snapshot (second arg) with a former
origin LV (first arg) to reverse a splitsnapshot command.
.P
.B lvconvert
\fB-s\fP|\fB--snapshot\fP
\fILV\fP \fILV1\fP
.RS
[ \fB--type snapshot\fP ] (implied)
.br
[ \fB-c\fP|\fB--chunksize\fP \fISize\fP[k|\:UNIT] ]
.br
[ \fB-Z\fP|\fB--zero\fP \fBy\fP|\fBn\fP ]
.br
[ COMMON_OPTIONS ]
.sp
LV1 types: linear striped
.RE
.
.P
\(em
.P
.
Poll LV to continue conversion (also see --startpoll)
or waits till conversion/mirror syncing is finished
.P
.B lvconvert
\fILV1\fP
.RS
[ COMMON_OPTIONS ]
.sp
LV1 types: mirror raid
.RE
